{"version":3,"file":"index.js","sources":["src/checkers/isAction.js","src/selectors/index.js","src/url-pattern/utils.js","src/url-pattern/addPathParams.js","src/url-pattern/addQueryParams.js","src/mappers/mapToFetch.js","src/mappers/mapToData.js","src/roadhog.js"],"sourcesContent":["export default (action) => {\n  if (!/.*_.*/.test(action)) {\n    throw new Error(`Wrong format for action: '${action}'. should be '<METHOD_NAME>_<RESOURCE_NAME>' (ie: GET_USERS)`)\n  }\n}\n\n","export const getConfig = ({ config }) => config\nexport const getAPI = state => getConfig(state).api\nexport const getMocks = state => getConfig(state).mocks\nexport const getResource = name => state => getAPI(state)[name]\n\nexport const getMethod = name => methodName => state => getResource(name)(state)[methodName]\n\nexport const getOptions = name => methodName => (state) => {\n  // raw data\n  const api = getAPI(state)\n  const resource = getResource(name)(state)\n  const method = getMethod(name)(methodName)(state)\n\n  // order is general -> specific\n  let options = { method: methodName }\n  if (api.options) options = { ...options, ...api.options }\n  if (resource.options) options = { ...options, ...resource.options }\n  if (method && method.options) options = { ...options, ...method.options }\n\n  return options\n}\n\nexport const getURL = name => methodName => (state) => {\n  // raw data\n  const resource = getResource(name)(state)\n  const method = getMethod(name)(methodName)(state)\n\n  if (method === undefined) return resource // example: { TODOS: '/api/todos' }\n  if (typeof method === 'string') return method // example : { TODOS: { GET: '/api/todos' } }\n  return method.url // example: { TODOS: { GET: { url: '/api/todos' } } }\n}\n\nexport const getFallback = url => methodName => (state) => {\n  const mocks = getMocks(state)\n  if (!mocks) return undefined\n\n  // mock by priority\n  const orderedMocks = [\n    // same method first\n    ...mocks.filter(m => m.method === methodName),\n    // no method then\n    ...mocks.filter(m => m.method === undefined),\n    // other method last\n    ...mocks.filter(m => m.method !== methodName && m.method !== undefined),\n  ]\n\n  // looking for right mock\n  const mock = orderedMocks.find(m => m.match.test(url))\n\n  // returns fallback\n  return (mock || {}).fallback\n}\n","export const encodeParams = (params) => {\n  if (!Array.isArray(params)) return encodeURIComponent(params)\n  return params.map(param => encodeURIComponent(param))\n}\n\nexport const isEmpty = (o) => {\n  return !o ||\n    ((typeof o === 'object' && Object.keys(o).length === 0) ||\n    (Array.isArray(o) && o.length === 0))\n}\n","import { encodeParams, isEmpty } from './utils'\n\nexport default url => (pathParams) => {\n  if (isEmpty(pathParams)) return url\n  return `${url}${url.endsWith('/') ? '' : '/'}${encodeParams(pathParams).join('/')}`\n}\n","import { encodeParams, isEmpty } from './utils'\n\nexport default url => (queryParams) => {\n  if (isEmpty(queryParams)) return url\n\n  const params = Object.keys(queryParams)\n    .map((k => `${k}=${encodeParams(queryParams[k])}`))\n\n  const slash = (url.endsWith('/') || url.endsWith('&') || url.endsWith('?')) ? '' : '/'\n  const questionMark = (url.endsWith('&') || url.endsWith('?')) ? '' : '?'\n\n  return `${url}${slash}${questionMark}${params.join('&')}`\n}\n","import { select } from 'redux-saga/effects'\nimport { getOptions, getURL } from '../selectors'\nimport { addPathParams, addQueryParams } from '../url-pattern'\n\nexport default action => function* (inputs = {}) {\n  // action pattern is `<METHOD_NAME>_<RESOURCE_NAME>`\n  const [methodName, name] = action.split(/_(.+)/)\n\n  // create a fetch options object\n  let options = yield select(getOptions(name)(methodName))\n\n  // body\n  // - body is an object : use JSON.stringify\n  // - body is a string : let it that way\n  const { body } = inputs\n  if (typeof body === 'string') options = { ...options, body }\n  else options = { ...options, body: JSON.stringify(body) }\n\n  // create a fetch url\n  let url = yield select(getURL(name)(methodName))\n  url = addPathParams(url)(inputs.path)\n  url = addQueryParams(url)(inputs.query)\n\n  return [url, options]\n}\n","export default fallback => function* (raw) {\n  /* -ko- => fallback */\n  if (!raw.ok && fallback) return fallback\n  /* -no content- => undefined */\n  if (+(raw.status) === 204) return undefined\n\n  const contentType = raw.headers && raw.headers.get('Content-Type')\n  if (contentType && contentType.includes('json')) {\n    try {\n      /* json */\n      return yield raw.json()\n    } catch (e) {\n      /* json with parsing error => text */\n      return yield raw.text()\n    }\n  }\n\n  return yield raw.text()\n}\n","import { select, put } from 'redux-saga/effects'\nimport { isAction } from './checkers'\nimport { mapToFetch, mapToData } from './mappers'\nimport { getFallback } from './selectors'\n\nconst apiEvent = (name, suffix, payload) => ({ type: `API_${name}_${suffix}`, payload })\n\n/**\n * Library that is connected to redux, use to fetch api, and to dispatch saga event\n * @param {string} action -\n *   the template of action is like this '<METHOD_NAME>_<RESOURCE_NAME>' => GET_USERS\n * @param {object} inputs -\n *   object contains body, query and path params => {body, query: {id: 1}, path: [user, 132]}\n * @return {object} - api response or fallback define on redux.\n */\nexport default action => function* (inputs) {\n  // check action pattern and eventually throw errors\n  isAction(action)\n\n  // get fetch options to make a fetch callback\n  const [url, options] = yield mapToFetch(action)(inputs)\n\n  // get the fallback (5XX errors)\n  const fallback = yield select(getFallback(url)(options.method))\n\n  // get the raw response, from tracer or from fetch\n  yield put(apiEvent(action, 'STARTED'))\n  const raw = yield fetch(url, options)\n\n  // retrieve data (either from request, either from mock -fallback-)\n  const data = yield mapToData(fallback)(raw)\n  if (!raw.ok && !fallback) yield put(apiEvent(action, 'ERROR', { raw, data, status: raw.status, statusText: raw.statusText }))\n\n  // return json response or fallback\n  yield put(apiEvent(action, 'END', { raw, data }))\n  return data\n}\n"],"names":["action","test","Error","getConfig","config","getAPI","state","api","getMocks","mocks","getResource","name","getMethod","methodName","getOptions","resource","method","options","getURL","undefined","url","getFallback","filter","m","find","match","fallback","encodeParams","params","Array","isArray","map","encodeURIComponent","param","isEmpty","o","Object","keys","length","pathParams","endsWith","join","queryParams","k","slash","questionMark","inputs","split","select","body","JSON","stringify","addPathParams","path","addQueryParams","query","raw","ok","status","headers","get","contentType","includes","json","text","apiEvent","suffix","payload","type","mapToFetch","put","fetch","mapToData","data","statusText"],"mappings":"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"}